/*
 * xbee-api
 * https://github.com/jouz/xbee-api
 *
 * Copyright (c) 2013 Jan Kolkmeier
 * Licensed under the MIT license.
 */

'use strict';

var util = require('util');
var events = require('events');

exports = module.exports;
exports.XBeeAPI = XBeeAPI;

var C       = exports.constants = require('./constants.js');
var frame_parser = exports._frame_parser = require('./frame-parser');
var frame_builder = exports._frame_builder = require('./frame-builder');

var _options = {
  raw_frames: false,
  api_mode: 1,
  module: "Any"
};

//-----------------------------
//var aux= new Buffer(30);
var aux=0;
var aux1=0;
var crearFrame=0;
//----------------------------

function XBeeAPI(options) {
  events.EventEmitter.call(this);
  options = options || {};
  options.__proto__ = _options;
  this.options = options;
  this.buildState = {
    buffer: new Buffer(512, 'ascii'),
    frameId: 0
  }

  this.parseState = {
    buffer: new Buffer(512, 'ascii'),
    offset: 0,         // Offset in buffer
    length: 0,         // Packet Length
    total: 0,          // To test Checksum
    checksum: 0x00,    // Checksum byte
    b: 0x00,           // Working byte
    escape_next: false,// For escaping in AP=2
    waiting: true
  };
   this.buffer;
  return this;
};
util.inherits(XBeeAPI, events.EventEmitter);

XBeeAPI.prototype.escape = function(buffer) {
  if (this.escapeBuffer == undefined)
    this.escapeBuffer = new Buffer(512, 'ascii');

  var offset = 0;
  this.escapeBuffer.writeUInt8(buffer[0], offset++);
  for (var i = 1; i < buffer.length; i++) {
    if (C.ESCAPE_BYTES.indexOf(buffer[i]) > -1) {
      this.escapeBuffer.writeUInt8(C.ESCAPE, offset++);
      this.escapeBuffer.writeUInt8(buffer[i] ^ C.ESCAPE_WITH, offset++);
    } else {
      this.escapeBuffer.writeUInt8(buffer[i], offset++);
    }
  }

  return new Buffer(this.escapeBuffer.slice(0, offset));
}

XBeeAPI.prototype.buildFrame = function(frame) {
  var S = this.buildState;
  var offset = 0;
  S.buffer.writeUInt8(C.START_BYTE, offset++);
  S.buffer.writeUInt8(0x00, offset++); // MSB length
  S.buffer.writeUInt8(0x00, offset++); // LSB length

  // Write payload
  offset = frame_builder[frame.type].apply(this, [ offset, frame ]);
  var length = offset - 3; // we have added this many bytes after head

  // Update Length
  S.buffer.writeUInt8(length % 256, 2); // LSB length
  if (length > 255)
    S.buffer.writeUInt8(length >>> 8, 1); // MSB length

  // Calculate & Append Checksum
  var checksum = 0;
  for (var i = 0; i < length; i++) checksum += S.buffer[i+3];
  S.buffer.writeUInt8(255 - (checksum % 256), length+3);
 
  if (this.options.api_mode == 2)
    return this.escape(S.buffer.slice(0, length+4));
  else
    console.log("xbee-api=>buildFrame=>Buffer", S.buffer.slice(0, length+4));
    return new Buffer(S.buffer.slice(0, length+4));
}

XBeeAPI.prototype.myBuildFrame = function() {
    var offset = 0;
    var S=this;
  //  if (!S.buffer) {
  //      S.buffer = new Buffer(20,"HEX")
        console.log("Crear Buffer BuilderFrame");
   //   }
    var buff=new Buffer(1,"HEX")
   buff.writeUInt8(0x7E, offset++);
   /*buff.writeUInt8(0x11, offset++);
   buff.writeUInt8(0x7E, offset++);
   buff.writeUInt8(0xAB, offset++);
   buff.writeUInt8(0xCD, offset++);
   buff.writeUInt8(0xEF, offset++);
   buff.writeUInt8(0xAB, offset++);
   buff.writeUInt8(0xCD, offset++);
    buff.writeUInt8(0x00, offset++);
    buff.writeUInt8(0x00, offset++);
   buff.writeUInt8(0x99, offset++);*/
   console.log("frame to send=>", buff.toString("HEX"));
   return (buff);
}


var flagPrincipioTrama=0;
var enableConcatBuff=0;
var flagParseFrame=0;
var principioAlmacenado=0;

XBeeAPI.prototype.myParser = function(data) {
    //console.log("My parser");
    var numIteraciones=0;
    var self = this;
    var i=0;
    if (!self.buffer) {
        self.buffer = new Buffer("HEX")
       // console.log("Crear Buffer Parser");
    } /*else {
        var bufferList = [self.buffer, data]
        self.buffer = Buffer.concat(bufferList)
        console.log("Concat Buffer");
     }*/
    for (var cont=0;cont<=data.length+1;cont++){
        if(data[cont]==0x7E || flagPrincipioTrama==1) {
            console.log("detectado inicio trama");
            self.buffer[numIteraciones]=data[cont];
            numIteraciones++;
            self.buffer=self.buffer.slice(0, cont);
            flagPrincipioTrama=1;
            enableConcatBuff=1;
            if(cont==data.length) flagPrincipioTrama=0;
        }
    }


   if (enableConcatBuff==1 && principioAlmacenado==1)
       self.buffer = Buffer.concat([self.buffer, data]);

    principioAlmacenado=1;


    for (var cont1=0;cont1<=data.length+1;cont1++) {
        if (data[cont1] == 0x99) {
            console.log("detectado final trama");
            enableConcatBuff = 0;
            flagParseFrame = 1;
            principioAlmacenado = 0;
            self.buffer = self.buffer.slice(0, self.buffer.length + data.length - cont1);
           // console.log("FINAL", self.buffer);
        }
    }


    if (flagParseFrame==1) {
        console.log("Buffer, myParser", self.buffer.toString("HEX"));
        frame_parser["ARTURO"](this.buffer, self.buffer.slice(0, self.buffer.length - 1));
        flagParseFrame=0;
    }
}

var contMuestras=0;
var noConcat=0;

XBeeAPI.prototype.mySecondParser = function(data) {
    console.log("mySeconParser");
        if (!this.buffer) {
        this.buffer = new Buffer("HEX")
        this.buffer=data;
        noConcat=0;
        console.log("new buffer", this.buffer.toString("HEX"));
        //this.buffer=0;
        //console.log("null buffer????", this.buffer.toString("HEX"));
        // console.log("Crear Buffer Parser");
    }
    contMuestras+=data.length;

    if(noConcat==1) {
        this.buffer = Buffer.concat([this.buffer, data]);

    }
    noConcat=1;
    console.log("this.buffer:", this.buffer.toString("HEX"));
    if (contMuestras>2) {
        contMuestras = 0;
     frame_parser["getRssi"](this.buffer, this.buffer.slice(0, 3));
     this.buffer=0;
        noConcat=0;
    }
}







//Note that this expects the whole frame to be escaped!
 XBeeAPI.prototype.parseFrame = function(buffer) {
 var frame = {
 type: buffer.readUInt8(3) // Read Frame Type
 };
 // Frame Type Specific Parsing, drop start, legth, type and checksum
 frame_parser[frame.type](frame, buffer.slice(4, buffer.length-1));
 return frame;
 }


XBeeAPI.prototype.nextFrameId = function() {
  this.buildState.frameId++;
  if (this.buildState.frameId > 255) {
    this.buildState.frameId = 1;
  }
  return this.buildState.frameId;
}


XBeeAPI.prototype.rawParser = function() {
  var self = this;
  return function(emitter, buffer) {
    self.parseRaw(buffer);
  }
}

XBeeAPI.prototype.parseRaw = function(buffer) {
    console.log("parseRaw working");
  var S = this.parseState;
  for(var i = 0; i < buffer.length; i++) {
    S.b = buffer[i];
    if (S.b == C.START_BYTE && S.waiting) {
      S.length = 0;
      S.total = 0;
      S.checksum = 0x00;
      S.offset = 0;
      S.escape_next = false;
      S.waiting = false;
    }

    if (this.options.api_mode == 2 && S.b == C.ESCAPE) {
      S.escape_next = true;
      continue;
    }

    if (S.escape_next) {
      S.b = 0x20 ^ S.b;
      S.escape_next = false;
    }

    S.buffer.writeUInt8(S.b, S.offset++);
    
    if (S.offset == 1) {
      continue;
    }

    if (S.offset == 2) {
      S.length  = S.b << 8; // most sign. bit of the length
      continue;
    }
    if (S.offset == 3) {
      S.length += S.b;     // least sign. bit of the length
      continue;
    }

    if (S.offset > 3) {
      if (S.offset < S.length+4) {
        S.total += S.b;
        continue;
      } else {
        S.checksum = S.b;
      }
    }

    if (S.length > 0 && S.offset == S.length + 4) {
      S.waiting = true;
      if (S.checksum != (255 - (S.total % 256))) {
        throw new Error("Checksum Mismatch", S);
        console.log("checksum error");
      } else if (this.options.raw_frames) {
        this.emit("frame_raw", S.buffer.slice(0, S.offset));
      } else {
        this.emit("frame_object",
                     this.parseFrame(S.buffer.slice(0, S.offset)));
      }
    }
  }
}
